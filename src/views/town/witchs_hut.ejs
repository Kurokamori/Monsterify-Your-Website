<% /* Set the title and other variables for the layout */ %>
<% title = 'Witch\'s Hut' %>

<% /* Add custom styles */ %>
<% style = `
<style>
  .location-card {
    background-color: var(--card-background);
    border-radius: 0.75rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    transition: transform 0.3s, box-shadow 0.3s;
  }

  .location-card:hover {
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
  }

  .location-card-content {
    padding: 1.25rem;
    background-color: var(--card-background);
  }

  .btn-primary {
    background-color: var(--accent-color);
    color: var(--background-color);
    font-weight: 500;
    transition: all 0.2s;
  }

  .btn-primary:hover:not(:disabled) {
    background-color: var(--accent-hover);
    transform: translateY(-2px);
  }

  .btn-primary:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .btn-secondary {
    background-color: var(--nav-background);
    color: var(--text-color);
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    font-weight: 500;
    transition: all 0.2s;
  }

  .btn-secondary:hover {
    background-color: var(--nav-hover);
  }

  .text-shadow-lg {
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
  }

  .location-banner {
    height: 200px;
    object-fit: cover;
  }
</style>
` %>

<div class="container mx-auto px-4">
  <div>
    <img src="https://i.imgur.com/5cgcSGC.png" alt="Witch's Hut Banner" class="location-banner w-full object-cover rounded-lg shadow-lg">
    <div class="flex flex-col items-center">
      <div class="flex items-center mb-4 w-full">
        <a href="/town/visit" class="btn-secondary mr-4 hover:scale-105 transition-transform">
          <i class="fas fa-arrow-left mr-2"></i> Back to Town
        </a>
        <h2 class="text-2xl font-display font-bold text-center text-amber-400 text-shadow-lg">Witch's Hut</h2>
      </div>
      <p class="text-center text-sm text-gray-200 mb-4">Transform your monsters into more powerful forms with the help of the town witch's evolution magic.</p>
    </div>
  </div>

  <div class="grid grid-cols-1 gap-6 mt-6">
    <!-- Monster Evolution Section -->
    <div class="location-card overflow-hidden bg-gray-900/80 border border-gray-800 rounded-xl shadow-xl">
      <div class="p-6">
        <h3 class="text-2xl font-bold text-amber-400 mb-4 text-center">Monster Evolution</h3>
        <p class="text-sm text-gray-300 mb-4">Evolve your monsters into more powerful forms. Different monster types evolve in different ways - Pok√©mon evolve based on their evolution paths, Digimon follow their digivolution lines, and Yokai cannot evolve. Some evolutions may require special items.</p>

        <div class="flex justify-end mb-4">
          <a href="/town/shop/evolution_shop" class="text-xs text-amber-400 hover:text-amber-300 transition-colors">
            <i class="fas fa-shopping-basket mr-1"></i> Visit Shop for Evolution Items
          </a>
        </div>

        <form id="evolution-form" class="bg-gray-900/90 p-6 rounded-xl mb-6 shadow-2xl border border-gray-800">
          <h4 class="text-amber-400 mb-3 font-semibold text-center text-xl">Evolve a Monster</h4>
          <p class="text-sm text-gray-300 mb-6 text-center leading-relaxed">Select a monster to evolve and provide the required information. Evolution is permanent and will make your monster stronger!</p>

          <!-- Trainer Selection -->
          <div class="mb-6">
            <div class="flex items-center mb-2">
              <i class="fas fa-user text-blue-400 mr-2"></i>
              <label for="trainer-select" class="block text-sm text-amber-400 font-semibold">Select Trainer</label>
            </div>
            <select
              id="trainer-select"
              name="trainerId"
              class="block w-full h-12 pl-3 pr-10 py-2 bg-gray-800/90 text-white placeholder-gray-400 border border-gray-700 rounded-lg focus:outline-none focus:border-amber-400 focus:ring-1 focus:ring-amber-400"
              required
            >
              <option value="">-- Select a Trainer --</option>
            </select>
          </div>

          <!-- Monster Selection -->
          <div id="monster-selection-container" class="mb-6 hidden">
            <div class="flex items-center mb-2">
              <i class="fas fa-dragon text-blue-400 mr-2"></i>
              <label for="monster-select" class="block text-sm text-amber-400 font-semibold">Select Monster</label>
            </div>
            <select
              id="monster-select"
              name="monsterId"
              class="block w-full h-12 pl-3 pr-10 py-2 bg-gray-800/90 text-white placeholder-gray-400 border border-gray-700 rounded-lg focus:outline-none focus:border-amber-400 focus:ring-1 focus:ring-amber-400"
              required
              disabled
            >
              <option value="">-- Select a Monster --</option>
            </select>
          </div>

          <!-- Evolution Preview -->
          <div id="evolution-preview" class="text-sm text-gray-300 mb-4 italic text-center hidden">
            Select a monster to see evolution options
          </div>

          <!-- Species Selection (Hidden by default) -->
          <div id="species-selection" class="mb-6 hidden">
            <div class="flex items-center mb-2">
              <i class="fas fa-dna text-blue-400 mr-2"></i>
              <label for="species-select" class="block text-sm text-amber-400 font-semibold">Select Species Form</label>
            </div>
            <select
              id="species-select"
              name="speciesIndex"
              class="block w-full h-12 pl-3 pr-10 py-2 bg-gray-800/90 text-white placeholder-gray-400 border border-gray-700 rounded-lg focus:outline-none focus:border-amber-400 focus:ring-1 focus:ring-amber-400"
            >
            </select>
          </div>

          <!-- Evolution Selection (Hidden by default) -->
          <div id="evolution-selection" class="mb-6 hidden">
            <div class="flex items-center mb-2">
              <i class="fas fa-arrow-up text-blue-400 mr-2"></i>
              <label for="evolution-select" class="block text-sm text-amber-400 font-semibold">Select Evolution</label>
            </div>
            <select
              id="evolution-select"
              name="selectedEvolution"
              class="block w-full h-12 pl-3 pr-10 py-2 bg-gray-800/90 text-white placeholder-gray-400 border border-gray-700 rounded-lg focus:outline-none focus:border-amber-400 focus:ring-1 focus:ring-amber-400"
            >
              <option value="">-- Select Evolution --</option>
            </select>
          </div>

          <!-- Item Usage Selection -->
          <div id="item-usage-container" class="mb-6 hidden">
            <div class="flex items-center mb-2">
              <i class="fas fa-gem text-blue-400 mr-2"></i>
              <label class="block text-sm text-amber-400 font-semibold">Use Evolution Item?</label>
            </div>
            <div class="flex gap-4">
              <label class="inline-flex items-center">
                <input type="radio" name="useItem" value="no" class="form-radio text-amber-400" checked>
                <span class="ml-2 text-gray-300">No</span>
              </label>
              <label class="inline-flex items-center">
                <input type="radio" name="useItem" value="yes" class="form-radio text-amber-400">
                <span class="ml-2 text-gray-300">Yes</span>
              </label>
            </div>
          </div>

          <!-- Item Selection (Hidden by default) -->
          <div id="item-selection" class="mb-6 hidden">
            <div class="flex items-center mb-2">
              <i class="fas fa-scroll text-blue-400 mr-2"></i>
              <label for="item-select" class="block text-sm text-amber-400 font-semibold">Select Evolution Item</label>
            </div>
            <select
              id="item-select"
              name="itemName"
              class="block w-full h-12 pl-3 pr-10 py-2 bg-gray-800/90 text-white placeholder-gray-400 border border-gray-700 rounded-lg focus:outline-none focus:border-amber-400 focus:ring-1 focus:ring-amber-400"
            >
              <option value="">-- Select an Item --</option>
            </select>
          </div>

          <!-- Submission URL -->
          <div id="submission-url-container" class="mb-6">
            <div class="flex items-center mb-2">
              <i class="fas fa-image text-blue-400 mr-2"></i>
              <label for="submission-url" class="block text-sm text-amber-400 font-semibold">Artwork Submission</label>
            </div>
            <p class="text-xs text-gray-400 mb-3">Provide a link to your evolution artwork. This is required to complete the evolution process.</p>
            <div class="relative">
              <span class="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-500">
                <i class="fas fa-link"></i>
              </span>
              <input
                type="url"
                id="submission-url"
                name="submissionUrl"
                class="block w-full h-12 pl-10 pr-3 py-2 bg-gray-800/90 text-white placeholder-gray-400 border border-gray-700 rounded-lg focus:outline-none focus:border-amber-400 focus:ring-1 focus:ring-amber-400"
                placeholder="Paste your evolution artwork URL here"
                required
              >
            </div>
          </div>

          <!-- Evolve Button -->
          <div id="evolve-button-container" class="mt-8">
            <button
              id="evolve-button"
              type="submit"
              class="block w-full h-14 bg-gradient-to-br from-amber-500 to-amber-700 text-white font-semibold rounded-lg shadow-lg transition-all duration-200 hover:from-amber-600 hover:to-amber-800 disabled:opacity-50 disabled:cursor-not-allowed"
              disabled
            >
              <div class="flex items-center justify-center gap-2">
                <i class="fas fa-arrow-up"></i>
                <span>Evolve Monster</span>
              </div>
            </button>
          </div>
        </form>
      </div>
    </div>


  </div>
</div>

<style>
.text-shadow {
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

.text-shadow-lg {
  text-shadow: 0 4px 8px rgba(0, 0, 0, 0.8);
}

.location-card {
  background-color: var(--card-background);
  border-radius: 0.75rem;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  transition: transform 0.3s, box-shadow 0.3s;
}

.location-card:hover {
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
}

.location-card-content {
  padding: 1.25rem;
  background-color: var(--card-background);
}

.btn-primary {
  background-color: var(--accent-color);
  color: var(--background-color);
  font-weight: 500;
  transition: all 0.2s;
}

.btn-primary:hover:not(:disabled) {
  background-color: var(--accent-hover);
  transform: translateY(-2px);
}

.btn-primary:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.btn-secondary {
  background-color: var(--secondary-color);
  color: var(--text-color);
  font-weight: 500;
  padding: 0.5rem 1rem;
  border-radius: 0.375rem;
  transition: all 0.2s;
}

.btn-secondary:hover {
  background-color: var(--secondary-hover);
}

/* Base styles matching the site theme */
.witch-hut-container {
    background-color: var(--background-color);
    border-radius: 1rem;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    padding: 2rem;
}

/* Evolution form styling */
.evolution-form {
    background-color: rgba(31, 41, 55, 0.9) !important;
    border-radius: 0.75rem !important;
    padding: 2rem !important;
    border: 1px solid rgb(55, 65, 81) !important;
    margin-bottom: 1.5rem !important;
}

/* Remove hover effect */
.evolution-form:hover {
    background-color: rgba(31, 41, 55, 0.9) !important;
}

/* Select inputs */
.select-container {
    margin-bottom: 1.5rem;
}

select {
    width: 100%;
    padding: 0.75rem;
    background-color: var(--input-background);
    border: 1px solid var(--divider-color);
    border-radius: 0.5rem;
    color: var(--text-color);
    transition: all 0.2s ease;
}

select:focus {
    border-color: var(--accent-color);
    box-shadow: 0 0 0 2px rgba(214, 163, 57, 0.2);
    outline: none;
}

/* URL input styling */
.url-input-container {
    position: relative;
    margin-bottom: 1.5rem;
}

.url-input {
    width: 100%;
    padding: 0.75rem;
    background-color: var(--input-background);
    border: 1px solid var(--divider-color);
    border-radius: 0.375rem;
    color: var(--text-color);
    transition: all 0.2s ease;
    font-size: var(--font-size-base);
    padding-left: 2.5rem; /* Space for icon */
}

.url-input:focus {
    outline: none;
    border-color: var(--accent-color);
    box-shadow: 0 0 0 2px rgba(214, 163, 57, 0.2);
}

.url-input:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Icon styling */
.input-icon {
    position: absolute;
    left: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-color);
    opacity: 0.7;
}

/* Label styling to match your site */
.form-label {
    display: block;
    margin-bottom: 0.5rem;
    color: var(--text-color);
    font-weight: 500;
}

.helper-text {
    font-size: 0.875rem;
    color: var(--text-color);
    opacity: 0.7;
    margin-top: 0.25rem;
}

/* Evolution preview */
.evolution-preview {
    background-color: var(--nav-background);
    border-radius: 0.75rem;
    padding: 1.5rem;
    margin: 1.5rem 0;
    border: 1px solid var(--divider-color);
}

/* Buttons */
.evolve-button {
    width: 100%;
    padding: 1rem;
    background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));
    color: var(--background-color);
    border: none;
    border-radius: 0.5rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.evolve-button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(214, 163, 57, 0.3);
}

.evolve-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: var(--nav-background);
}

/* Item selection */
.item-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 1rem;
    margin: 1rem 0;
}

.item-card {
    background-color: var(--nav-background);
    border: 1px solid var(--divider-color);
    border-radius: 0.5rem;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.item-card:hover {
    background-color: var(--nav-hover);
    transform: translateY(-2px);
}

.item-card.selected {
    border-color: var(--accent-color);
    box-shadow: 0 0 0 2px rgba(214, 163, 57, 0.2);
}

/* Effect display */
.effect-display {
    background-color: var(--nav-background);
    border-radius: 0.5rem;
    padding: 1rem;
    margin-top: 1rem;
    font-style: italic;
    color: var(--text-color);
    opacity: 0.9;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .witch-hut-container {
        padding: 1rem;
    }

    .item-grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    }
}

/* Animation effects */
.fade-in {
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Force override input styles */
#submission-url {
  width: 100% !important;
  height: 48px !important;
  background-color: rgb(31 41 55 / 0.9) !important;
  color: white !important;
  border: 1px solid rgb(55 65 81) !important;
  border-radius: 0.5rem !important;
  padding: 0.75rem 1rem 0.75rem 2.5rem !important;
}

#submission-url:focus {
  outline: none !important;
  border-color: rgb(217 119 6) !important;
  box-shadow: 0 0 0 2px rgba(217, 119, 6, 0.2) !important;
}

/* Force override button styles */
#evolve-button {
  width: 100% !important;
  height: 56px !important;
  background: linear-gradient(135deg, rgb(214 163 57), rgb(184 138 48)) !important; /* matches --accent-color and --accent-hover */
  color: white !important;
  border: none !important;
  border-radius: 0.5rem !important;
  font-weight: 600 !important;
  cursor: pointer !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  margin: 1.5rem 0 !important;
}

#evolve-button:hover {
  background: linear-gradient(135deg, rgb(184 138 48), rgb(154 108 38)) !important;
}

#evolve-button:disabled {
  opacity: 0.5 !important;
  cursor: not-allowed !important;
}

/* Ensure the content inside the button is centered */
#evolve-button div {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  width: 100% !important;
}

/* Trainer select dropdown styling */
#trainer-select {
  width: 100% !important;
  height: 48px !important;
  background-color: rgb(31 41 55 / 0.9) !important;
  color: white !important;
  border: 1px solid rgb(55 65 81) !important;
  border-radius: 0.5rem !important;
  padding: 0.75rem 1rem !important;
  appearance: none !important;
  cursor: pointer !important;
}

#trainer-select:focus {
  outline: none !important;
  border-color: rgb(217 119 6) !important;
  box-shadow: 0 0 0 2px rgba(217, 119, 6, 0.2) !important;
}
</style>

<% /* Add custom scripts */ %>
<% script = `
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Previous JavaScript functionality...

    // Add URL validation visual feedback
    const submissionUrl = document.getElementById('submission-url');
    const validationIndicator = document.querySelector('.link-validation-indicator');

    submissionUrl.addEventListener('input', function() {
        const url = this.value.trim();
        const isValid = url.startsWith('http') && url.length > 10;

        validationIndicator.classList.remove('valid', 'invalid');
        if (url.length > 0) {
            validationIndicator.classList.add(isValid ? 'valid' : 'invalid');
        }
    });

    // Add animation when showing elements
    const showElement = (element) => {
        if (element) {
            element.classList.remove('hidden');
            element.classList.add('fade-in');
        }
    };

    // Previous event handlers...
  });
</script>
` %>

<script>
  // Function to load trainers into the dropdown
  async function loadTrainers() {
    try {
      console.log('Fetching trainers from /api/trainers/user');
      const response = await fetch('/api/trainers/user');
      if (!response.ok) {
        console.error(`Failed to fetch trainers: ${response.status} ${response.statusText}`);
        throw new Error(`Failed to fetch trainers: ${response.status} ${response.statusText}`);
      }

      const trainers = await response.json();
      console.log(`Received ${trainers ? trainers.length : 0} trainers:`, trainers);

      const trainerSelect = document.getElementById('trainer-select');
      if (!trainerSelect) {
        console.error('Trainer select element not found in the DOM');
        return;
      }

      trainerSelect.innerHTML = '<option value="">-- Select a Trainer --</option>';

      if (trainers && trainers.length > 0) {
        trainers.forEach(trainer => {
          const option = document.createElement('option');
          option.value = trainer.id;
          option.textContent = `${trainer.name} (Level ${trainer.level || 1})`;
          trainerSelect.appendChild(option);
        });
        // Enable the select after populating
        trainerSelect.disabled = false;
        console.log('Trainers loaded successfully');
      } else {
        console.warn('No trainers found for the current user');
        const option = document.createElement('option');
        option.value = "";
        option.textContent = "No trainers found";
        option.disabled = true;
        trainerSelect.appendChild(option);
        trainerSelect.disabled = true;
      }
    } catch (error) {
      console.error('Error loading trainers:', error);
      const trainerSelect = document.getElementById('trainer-select');
      if (trainerSelect) {
        trainerSelect.innerHTML = '<option value="">Error loading trainers</option>';
        trainerSelect.disabled = true;
      }

      // Try alternative API endpoints as fallback
      try {
        // First try the API router endpoint
        console.log('Trying fallback API endpoint /api/trainers/user');
        const fallbackResponse = await fetch('/api/trainers/user');
        if (fallbackResponse.ok) {
          const fallbackTrainers = await fallbackResponse.json();
          console.log('Fallback API returned trainers:', fallbackTrainers);

          if (fallbackTrainers && fallbackTrainers.length > 0 && trainerSelect) {
            trainerSelect.innerHTML = '<option value="">-- Select a Trainer --</option>';
            fallbackTrainers.forEach(trainer => {
              const option = document.createElement('option');
              option.value = trainer.id;
              option.textContent = `${trainer.name} (Level ${trainer.level || 1})`;
              trainerSelect.appendChild(option);
            });
            trainerSelect.disabled = false;
            console.log('Trainers loaded from fallback API');
            return; // Exit if successful
          }
        }

        // If that fails, try the user trainers endpoint
        console.log('Trying second fallback API endpoint /api/user/trainers');
        const secondFallbackResponse = await fetch('/api/user/trainers');
        if (secondFallbackResponse.ok) {
          const secondFallbackTrainers = await secondFallbackResponse.json();
          console.log('Second fallback API returned trainers:', secondFallbackTrainers);

          if (secondFallbackTrainers && secondFallbackTrainers.length > 0 && trainerSelect) {
            trainerSelect.innerHTML = '<option value="">-- Select a Trainer --</option>';
            secondFallbackTrainers.forEach(trainer => {
              const option = document.createElement('option');
              option.value = trainer.id;
              option.textContent = `${trainer.name} (Level ${trainer.level || 1})`;
              trainerSelect.appendChild(option);
            });
            trainerSelect.disabled = false;
            console.log('Trainers loaded from second fallback API');
          }
        }
      } catch (fallbackError) {
        console.error('All fallback APIs failed:', fallbackError);
      }
    }
  }

  // Function to load monsters for a trainer
  async function loadMonsters(trainerId) {
    const monsterSelect = document.getElementById('monster-select');
    const monsterContainer = document.getElementById('monster-selection-container');

    if (!trainerId) {
      monsterSelect.disabled = true;
      monsterContainer.classList.add('hidden');
      return;
    }

    try {
      console.log(`Fetching monsters for trainer ${trainerId}`);
      const response = await fetch(`/api/trainers/${trainerId}/monsters`);
      if (!response.ok) {
        console.error(`Failed to fetch monsters: ${response.status} ${response.statusText}`);
        throw new Error(`Failed to fetch monsters: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      console.log('Received monster data:', data); // Debug log

      monsterSelect.innerHTML = '<option value="">-- Select a Monster --</option>';

      // Check if data is an array directly or if monsters are in a property
      let monsters = [];
      if (Array.isArray(data)) {
        monsters = data;
      } else if (data.monsters && Array.isArray(data.monsters)) {
        monsters = data.monsters;
      } else if (typeof data === 'object' && data !== null) {
        // If it's an object but not an array and doesn't have a monsters property,
        // it might be a single monster object
        monsters = [data];
      }

      if (monsters.length > 0) {
        monsters.forEach(monster => {
          const option = document.createElement('option');
          // Handle different possible ID properties (mon_id or id)
          option.value = monster.mon_id || monster.id;
          // Handle different possible name properties
          const monsterName = monster.name || monster.monster_name || monster.species_name || monster.species1;
          const monsterLevel = monster.level || monster.monster_level || 1;
          option.textContent = `${monsterName} (Level ${monsterLevel})`;
          monsterSelect.appendChild(option);
        });
        monsterSelect.disabled = false;
        monsterContainer.classList.remove('hidden');
        console.log(`Loaded ${monsters.length} monsters for trainer ${trainerId}`);
      } else {
        console.warn(`No monsters found for trainer ${trainerId}`);
        monsterSelect.innerHTML = '<option value="">No monsters available</option>';
        monsterSelect.disabled = true;
      }
    } catch (error) {
      console.error('Error loading monsters:', error);
      monsterSelect.innerHTML = '<option value="">Error loading monsters</option>';
      monsterSelect.disabled = true;

      // Try alternative API endpoint
      try {
        console.log(`Trying fallback API endpoint for monsters: /api/trainers/${trainerId}/monsters`);
        const fallbackResponse = await fetch(`/api/trainers/${trainerId}/monsters`);
        if (fallbackResponse.ok) {
          const fallbackData = await fallbackResponse.json();
          console.log('Fallback API returned monsters:', fallbackData);

          // Check if data is an array directly or if monsters are in a property
          let fallbackMonsters = [];
          if (Array.isArray(fallbackData)) {
            fallbackMonsters = fallbackData;
          } else if (fallbackData.monsters && Array.isArray(fallbackData.monsters)) {
            fallbackMonsters = fallbackData.monsters;
          } else if (typeof fallbackData === 'object' && fallbackData !== null) {
            // If it's an object but not an array and doesn't have a monsters property,
            // it might be a single monster object
            fallbackMonsters = [fallbackData];
          }

          if (fallbackMonsters.length > 0 && monsterSelect) {
            monsterSelect.innerHTML = '<option value="">-- Select a Monster --</option>';
            fallbackMonsters.forEach(monster => {
              const option = document.createElement('option');
              // Handle different possible ID properties (mon_id or id)
              option.value = monster.mon_id || monster.id;
              // Handle different possible name properties
              const monsterName = monster.name || monster.monster_name || monster.species_name || monster.species1;
              const monsterLevel = monster.level || monster.monster_level || 1;
              option.textContent = `${monsterName} (Level ${monsterLevel})`;
              monsterSelect.appendChild(option);
            });
            monsterSelect.disabled = false;
            monsterContainer.classList.remove('hidden');
            console.log(`Loaded ${fallbackMonsters.length} monsters from fallback API`);
          }
        }
      } catch (fallbackError) {
        console.error('Fallback API for monsters also failed:', fallbackError);
      }
    }
  }

  // Function to load evolution items for the selected trainer
  async function loadItems() {
    const itemSelect = document.getElementById('item-select');
    const itemContainer = document.getElementById('item-selection');
    const trainerId = document.getElementById('trainer-select').value;

    if (!trainerId) {
      console.warn('No trainer selected, cannot load items');
      itemSelect.innerHTML = '<option value="">-- Select a Trainer First --</option>';
      itemSelect.disabled = true;
      return;
    }

    try {
      console.log(`Fetching evolution items for trainer ${trainerId}`);
      const response = await fetch(`/api/trainers/${trainerId}/items/evolution`);
      if (!response.ok) {
        console.error(`Failed to fetch items: ${response.status} ${response.statusText}`);
        throw new Error(`Failed to fetch items: ${response.status} ${response.statusText}`);
      }

      const items = await response.json();
      console.log(`Received ${items ? items.length : 0} evolution items:`, items);

      itemSelect.innerHTML = '<option value="">-- Select an Item --</option>';

      // Filter items to only show ones the trainer has
      const availableItems = items.filter(item => item.quantity > 0);
      console.log(`Filtered ${availableItems.length} available items from ${items.length} total items`);

      if (availableItems && availableItems.length > 0) {
        availableItems.forEach(item => {
          const option = document.createElement('option');
          option.value = item.name;
          option.textContent = `${item.name} (${item.quantity})`;
          option.dataset.quantity = item.quantity;
          itemSelect.appendChild(option);
        });
        console.log('Evolution items loaded successfully');
        itemSelect.disabled = false;
      } else {
        console.warn('No evolution items found in trainer inventory');
        const option = document.createElement('option');
        option.value = "";
        option.textContent = "No evolution items in inventory";
        option.disabled = true;
        itemSelect.appendChild(option);
        itemSelect.disabled = true;

        // Add a link to the evolution shop
        const shopLink = document.createElement('div');
        shopLink.className = 'mt-2 text-center';
        shopLink.innerHTML = `
          <a href="/town/shop/evolution_shop" class="text-amber-400 hover:text-amber-300 transition-colors text-sm">
            <i class="fas fa-shopping-basket mr-1"></i> Visit Shop for Evolution Items
          </a>
        `;
        itemContainer.appendChild(shopLink);
      }
    } catch (error) {
      console.error('Error loading items:', error);
      itemSelect.innerHTML = '<option value="">Error loading items</option>';
      itemSelect.disabled = true;

      // Try alternative API endpoint
      try {
        console.log('Trying fallback API endpoint for items');
        const fallbackResponse = await fetch('/api/items/evolution');
        if (fallbackResponse.ok) {
          const fallbackItems = await fallbackResponse.json();
          console.log('Fallback API returned items:', fallbackItems);

          if (fallbackItems && fallbackItems.length > 0 && itemSelect) {
            itemSelect.innerHTML = '<option value="">-- Select an Item --</option>';
            fallbackItems.forEach(item => {
              const option = document.createElement('option');
              option.value = item.name;
              option.textContent = item.name;
              itemSelect.appendChild(option);
            });
            console.log('Items loaded from fallback API');
            itemSelect.disabled = false;
          }
        }
      } catch (fallbackError) {
        console.error('Fallback API for items also failed:', fallbackError);
      }
    }
  }

  // Event listener for trainer selection
  document.getElementById('trainer-select').addEventListener('change', function(e) {
    const trainerId = e.target.value;
    loadMonsters(trainerId);

    // If item usage is selected, reload items for the new trainer
    const useItemRadio = document.querySelector('input[name="useItem"]:checked');
    if (useItemRadio && useItemRadio.value === 'yes') {
      loadItems();
    }
  });

  // Function to load evolution options for a monster
  async function loadEvolutionOptions(monsterId) {
    const speciesContainer = document.getElementById('species-selection');
    const evolutionContainer = document.getElementById('evolution-selection');
    const evolutionPreview = document.getElementById('evolution-preview');
    const itemUsageContainer = document.getElementById('item-usage-container');

    // Validate monsterId
    if (!monsterId || monsterId === '' || isNaN(parseInt(monsterId))) {
      console.log('Invalid or empty monster ID, hiding evolution options');
      speciesContainer.classList.add('hidden');
      evolutionContainer.classList.add('hidden');
      evolutionPreview.textContent = 'Select a monster to see evolution options';
      evolutionPreview.classList.remove('hidden');
      itemUsageContainer.classList.add('hidden');
      return;
    }

    try {
      console.log(`Fetching evolution options for monster ${monsterId}`);
      evolutionPreview.textContent = 'Loading evolution options...';
      evolutionPreview.classList.remove('hidden');

      const response = await fetch(`/api/monsters/${monsterId}/evolution-options`);
      if (!response.ok) {
        console.error(`Failed to fetch evolution options: ${response.status} ${response.statusText}`);
        throw new Error(`Failed to fetch evolution options: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      console.log('Evolution data:', data); // Debug log

      // Check if we have a monster object in the response
      if (!data.monster) {
        console.error('No monster data in response');
        console.log('Response data structure:', Object.keys(data));
        evolutionPreview.textContent = 'Error: Monster data not found';

        // Try to handle the case where the response is in a different format
        if (data.canEvolve !== undefined) {
          console.log('Found canEvolve property, proceeding with available data');
          // Continue with the evolution options if available
          if (data.canEvolve && data.evolutionOptions && data.evolutionOptions.length > 0) {
            // Show evolution preview
            evolutionPreview.textContent = data.evolutionOptions.length === 1
              ? `This monster can evolve into: ${data.evolutionOptions[0]}`
              : `This monster has ${data.evolutionOptions.length} possible evolutions`;

            // Only show selection if multiple options exist
            const evolutionSelect = document.getElementById('evolution-select');
            evolutionSelect.innerHTML = '<option value="">-- Select Evolution --</option>';

            if (data.evolutionOptions.length > 1) {
              data.evolutionOptions.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                evolutionSelect.appendChild(optionElement);
              });
              document.getElementById('evolution-selection').classList.remove('hidden');
            } else {
              document.getElementById('evolution-selection').classList.add('hidden');
            }

            // Show item usage container
            document.getElementById('item-usage-container').classList.remove('hidden');
            return;
          } else {
            evolutionPreview.textContent = 'This monster cannot evolve at this time';
            document.getElementById('evolution-selection').classList.add('hidden');
            document.getElementById('item-usage-container').classList.add('hidden');
            return;
          }
        }
        return;
      }

      // Handle species selection if multiple species exist
      const monster = data.monster;
      const species = [monster.species1, monster.species2, monster.species3].filter(Boolean);
      const speciesSelect = document.getElementById('species-select');

      if (species.length > 1) {
        speciesSelect.innerHTML = '';
        species.forEach((speciesName, index) => {
          const option = document.createElement('option');
          const speciesNumber = index + 1; // 1-based index to match species1, species2, species3
          option.value = speciesNumber;
          option.textContent = `Species ${speciesNumber} - ${speciesName}`;
          option.dataset.speciesName = speciesName; // Store the species name for reference
          speciesSelect.appendChild(option);
        });
        speciesContainer.classList.remove('hidden');
        console.log(`Showing species selection with ${species.length} options`);
      } else {
        speciesContainer.classList.add('hidden');
        console.log('Hiding species selection - only one species available');
      }

      // Handle evolution options
      const evolutionSelect = document.getElementById('evolution-select');
      evolutionSelect.innerHTML = '<option value="">-- Select Evolution --</option>';

      if (data.canEvolve && data.evolutionOptions && data.evolutionOptions.length > 0) {
        // Show evolution preview
        evolutionPreview.textContent = data.evolutionOptions.length === 1
          ? `This monster can evolve into: ${data.evolutionOptions[0]}`
          : `This monster has ${data.evolutionOptions.length} possible evolutions`;

        // Only show selection if multiple options exist
        if (data.evolutionOptions.length > 1) {
          data.evolutionOptions.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option;
            optionElement.textContent = option;
            evolutionSelect.appendChild(optionElement);
          });
          evolutionContainer.classList.remove('hidden');
        } else {
          evolutionContainer.classList.add('hidden');
        }

        // Show item usage container
        itemUsageContainer.classList.remove('hidden');
      } else {
        evolutionPreview.textContent = 'This monster cannot evolve at this time';
        evolutionContainer.classList.add('hidden');
        itemUsageContainer.classList.add('hidden');
      }
    } catch (error) {
      console.error('Error loading evolution options:', error);
      evolutionPreview.textContent = 'Error loading evolution options';

      // Try fallback API
      try {
        console.log('Trying fallback API for evolution options');
        const fallbackResponse = await fetch(`/api/monsters/${monsterId}/evolution-options`);
        if (fallbackResponse.ok) {
          const fallbackData = await fallbackResponse.json();
          console.log('Fallback API returned evolution data:', fallbackData);

          if (fallbackData.canEvolve && fallbackData.evolutionOptions && fallbackData.evolutionOptions.length > 0) {
            // Show evolution preview
            evolutionPreview.textContent = fallbackData.evolutionOptions.length === 1
              ? `This monster can evolve into: ${fallbackData.evolutionOptions[0]}`
              : `This monster has ${fallbackData.evolutionOptions.length} possible evolutions`;

            // Only show selection if multiple options exist
            if (fallbackData.evolutionOptions.length > 1) {
              const evolutionSelect = document.getElementById('evolution-select');
              evolutionSelect.innerHTML = '<option value="">-- Select Evolution --</option>';

              fallbackData.evolutionOptions.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                evolutionSelect.appendChild(optionElement);
              });
              evolutionContainer.classList.remove('hidden');
            }

            // Show item usage container
            itemUsageContainer.classList.remove('hidden');
          }
        }
      } catch (fallbackError) {
        console.error('Fallback API for evolution options also failed:', fallbackError);
      }
    }
  }

  // Function to handle monster selection
  document.getElementById('monster-select').addEventListener('change', function(e) {
    const monsterId = e.target.value;
    console.log(`Monster selected with ID: ${monsterId}`);
    if (monsterId && monsterId !== '') {
      loadEvolutionOptions(monsterId);
    } else {
      // Hide evolution-related elements if no monster is selected
      document.getElementById('species-selection').classList.add('hidden');
      document.getElementById('evolution-selection').classList.add('hidden');
      document.getElementById('evolution-preview').textContent = 'Select a monster to see evolution options';
      document.getElementById('item-usage-container').classList.add('hidden');
      document.getElementById('item-selection').classList.add('hidden');
      // Update button state
      updateEvolveButtonState();
    }
  });

  // Event listener for item usage radio buttons
  document.querySelectorAll('input[name="useItem"]').forEach(radio => {
    radio.addEventListener('change', function(e) {
      const itemSelection = document.getElementById('item-selection');
      if (e.target.value === 'yes') {
        itemSelection.classList.remove('hidden');
        loadItems(); // Load the items
      } else {
        itemSelection.classList.add('hidden');
      }
    });
  });

  // Handle form submission
  document.getElementById('evolution-form').addEventListener('submit', async function(e) {
    e.preventDefault();

    // Get form values
    const trainerId = document.getElementById('trainer-select').value;
    const monsterId = document.getElementById('monster-select').value;
    const submissionUrl = document.getElementById('submission-url').value;
    const useItem = document.querySelector('input[name="useItem"]:checked').value;
    const itemSelect = document.getElementById('item-select');
    const itemName = useItem === 'yes' ? itemSelect.value : null;

    // Get selected evolution if available
    const evolutionSelect = document.getElementById('evolution-select');
    const selectedEvolution = evolutionSelect && !evolutionSelect.classList.contains('hidden') ? evolutionSelect.value : null;

    // Get selected species if available
    const speciesSelect = document.getElementById('species-select');
    let speciesIndex = null;

    if (speciesSelect && !speciesSelect.classList.contains('hidden') && speciesSelect.value) {
      // Convert to integer since we need a numeric value for the species index
      speciesIndex = parseInt(speciesSelect.value);
      console.log(`Selected species index: ${speciesIndex}`);
    } else {
      console.log('No species index selected, defaulting to species1');
      speciesIndex = 1; // Default to species1 if no selection
    }

    // Validate form
    if (!trainerId || !monsterId || !submissionUrl) {
      alert('Please fill out all required fields');
      return;
    }

    // Validate item selection if using an item
    if (useItem === 'yes') {
      if (!itemName) {
        alert('Please select an evolution item');
        return;
      }

      // Check if the selected option has a quantity attribute
      const selectedOption = itemSelect.options[itemSelect.selectedIndex];
      if (selectedOption && selectedOption.dataset.quantity) {
        const quantity = parseInt(selectedOption.dataset.quantity);
        if (quantity <= 0) {
          alert(`You don't have any ${itemName} in your inventory`);
          return;
        }
      }
    }

    // Disable submit button
    const submitButton = document.getElementById('evolve-button');
    submitButton.disabled = true;
    submitButton.innerHTML = '<div class="flex items-center justify-center gap-2"><i class="fas fa-spinner fa-spin"></i><span>Processing...</span></div>';

    try {
      console.log('Submitting evolution request with data:', {
        trainerId,
        monsterId,
        submissionUrl,
        useItem,
        itemName,
        selectedEvolution,
        speciesIndex
      });

      // Submit evolution request
      const response = await fetch(`/api/monsters/${monsterId}/evolve`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          trainerId,
          submissionUrl,
          useItem: useItem === 'yes',
          itemName,
          selectedEvolution,
          speciesIndex
        })
      });

      const result = await response.json();
      console.log('Evolution result:', result);

      if (result.success) {
        // Show success message
        alert(result.message || 'Evolution successful!');

        // Reset form
        document.getElementById('evolution-form').reset();

        // Hide sections
        document.getElementById('monster-selection-container').classList.add('hidden');
        document.getElementById('species-selection').classList.add('hidden');
        document.getElementById('evolution-selection').classList.add('hidden');
        document.getElementById('item-usage-container').classList.add('hidden');
        document.getElementById('item-selection').classList.add('hidden');
        document.getElementById('evolution-preview').textContent = 'Select a monster to see evolution options';

        // Reload trainers
        loadTrainers();
      } else {
        // Show error message
        alert(result.message || 'Evolution failed. Please try again.');
      }
    } catch (error) {
      console.error('Error processing evolution:', error);
      alert('An error occurred while processing the evolution. Please try again.');
    } finally {
      // Re-enable submit button
      submitButton.disabled = false;
      submitButton.innerHTML = '<div class="flex items-center justify-center gap-2"><i class="fas fa-arrow-up"></i><span>Evolve Monster</span></div>';
    }
  });

  // Enable/disable evolve button based on form state
  function updateEvolveButtonState() {
    const trainerId = document.getElementById('trainer-select').value;
    const monsterId = document.getElementById('monster-select').value;
    const submissionUrl = document.getElementById('submission-url').value;
    const evolutionPreview = document.getElementById('evolution-preview');
    const evolveButton = document.getElementById('evolve-button');

    console.log('Updating evolve button state with:', {
      trainerId,
      monsterId,
      submissionUrl,
      evolutionPreviewText: evolutionPreview ? evolutionPreview.textContent : 'null'
    });

    // Enable button if all required fields are filled and monster can evolve
    const canEvolve = evolutionPreview && evolutionPreview.textContent &&
                     !evolutionPreview.textContent.includes('cannot evolve') &&
                     !evolutionPreview.textContent.includes('Error') &&
                     !evolutionPreview.textContent.includes('Select a monster') &&
                     !evolutionPreview.textContent.includes('Loading');

    evolveButton.disabled = !trainerId || !monsterId || !submissionUrl || !canEvolve;
    console.log('Evolve button enabled:', !evolveButton.disabled);
  }

  // Add event listeners for form fields
  document.getElementById('trainer-select').addEventListener('change', updateEvolveButtonState);
  document.getElementById('monster-select').addEventListener('change', updateEvolveButtonState);
  document.getElementById('submission-url').addEventListener('input', updateEvolveButtonState);

  // Create a MutationObserver to watch for changes to the evolution preview text
  const evolutionPreview = document.getElementById('evolution-preview');
  if (evolutionPreview) {
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'characterData' || mutation.type === 'childList') {
          console.log('Evolution preview text changed:', evolutionPreview.textContent);
          updateEvolveButtonState();
        }
      });
    });

    // Start observing the evolution preview for changes
    observer.observe(evolutionPreview, {
      characterData: true,
      childList: true,
      subtree: true
    });
  }

  // Load trainers when the page loads
  document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM content loaded, loading trainers...');
    loadTrainers();
    updateEvolveButtonState();
  });

  // Backup to ensure trainers are loaded
  window.onload = function() {
    console.log('Window loaded, checking if trainers are loaded...');
    const trainerSelect = document.getElementById('trainer-select');
    if (trainerSelect && trainerSelect.options.length <= 1) {
      console.log('Trainers not loaded yet, loading now...');
      loadTrainers();
    }
    updateEvolveButtonState();
  };
</script>
